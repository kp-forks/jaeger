# Copyright (c) 2026 The Jaeger Authors.
# SPDX-License-Identifier: Apache-2.0

# CI Summary Report: fan-in workflow that posts a consolidated PR comment with
# performance metrics comparison and code coverage gating.
#
# Design: docs/adr/004-migrating-coverage-gating-to-github-actions.md
#
# This workflow is triggered by workflow_run (on "CI Orchestrator" completion)
# so that it can write PR comments from fork PRs while retaining write permissions.
# The CI Orchestrator completes only after all stages (unit tests + E2E) finish,
# ensuring all coverage-* artifacts are available when this job runs.

name: CI Summary Report
on:
  workflow_run:
    workflows: ["CI Orchestrator"]
    types: [completed]
permissions:
  contents: read
  pull-requests: write
  checks: write
jobs:
  summary-report:
    name: Summary Report
    if: ${{ github.event.workflow_run.event == 'pull_request' || github.event.workflow_run.head_branch == 'main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6
        with:
          ref: ${{ github.event.repository.default_branch }}

      - name: Install adm-zip
        run: npm install adm-zip

      # Downloads all artifacts from the triggering CI Orchestrator run.
      # Coverage artifacts (coverage-*) are extracted alongside metrics artifacts,
      # landing at .artifacts/coverage-<name>/ for later merging.
      # See: docs/adr/004-migrating-coverage-gating-to-github-actions.md (Step 4b)
      - name: Download all artifacts from triggering workflow
        id: download-artifacts
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const workflowRunId = context.payload.workflow_run.id;

            // List all artifacts from the triggering workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner,
              repo,
              run_id: workflowRunId,
            });

            // Download and extract each artifact
            const fs = require('fs');
            const path = require('path');
            const AdmZip = require('adm-zip');

            for (const artifact of artifacts.data.artifacts) {
              const download = await github.rest.actions.downloadArtifact({
                owner,
                repo,
                artifact_id: artifact.id,
                archive_format: 'zip',
              });

              const zip = new AdmZip(Buffer.from(download.data));
              zip.extractAllTo(path.join(process.env.GITHUB_WORKSPACE, '.artifacts', artifact.name), true);
              console.log(`Extracted artifact: ${artifact.name}`);
            }

            // Extract PR number (adapted from PDF logic)
            let prNumber = null;
            const pullRequest = await github.rest.pulls.list({
              owner,
              repo,
              head: `${context.payload.workflow_run.head_repository.full_name}:${context.payload.workflow_run.head_branch}`,
            });

            const prArtifactPath = path.join(process.env.GITHUB_WORKSPACE, '.artifacts', 'pr_number', 'pr_number.txt');
            if (fs.existsSync(prArtifactPath)) {
              prNumber = fs.readFileSync(prArtifactPath, 'utf8').trim();
              console.log(`Found PR Number from artifact: ${prNumber}`);
            } else {
              if (pullRequest.data.length > 0) {
                prNumber = pullRequest.data[0].number;
              } else {
                // Fallback to commit SHA if needed
                const commitSha = context.payload.workflow_run.head_sha;
                const prsForCommit = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: commitSha,
                });
                if (prsForCommit.data.length > 0) {
                  prNumber = prsForCommit.data[0].number;
                  console.log(`Found PR via commit SHA: #${prNumber}`);
                }
              }
            }

            if (prNumber) {
              console.log(`Found PR Number: ${prNumber}`);
              core.setOutput('pr_number', prNumber);
            } else {
              console.log('Could not determine PR number; PR comment and check runs will be skipped.');
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        if: success() && steps.download-artifacts.outputs.pr_number
        run: |
          python3 -m pip install prometheus-client
          npm install @actions/core @actions/github

      - name: Compare metrics and generate summary
        if: success() && steps.download-artifacts.outputs.pr_number
        id: compare-metrics
        shell: bash
        run: |
          bash ./scripts/e2e/metrics_summary.sh
        env:
          LINK_TO_ARTIFACT: "https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}"

      - name: Upload metrics comparison report as artifact
        if: success() && steps.download-artifacts.outputs.pr_number
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: metrics-comparison-report
          path: ./.artifacts/combined_summary.md
          retention-days: 30

      # =========================================================================
      # Coverage gating: merge all coverage-* profiles, compare against baseline,
      # and fail the check if coverage drops beyond the threshold.
      # See: docs/adr/004-migrating-coverage-gating-to-github-actions.md (Step 4c)
      # =========================================================================

      - name: Set up Go for coverage tools
        if: success()
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: 1.26.x
          cache-dependency-path: |
            ./go.sum
            ./internal/tools/go.sum

      - name: Install coverage tools
        if: success()
        run: make install-coverage-tools

      - name: Merge coverage profiles
        if: success()
        id: merge-coverage
        run: |
          mapfile -t COVER_FILES < <(find .artifacts -path "*/coverage-*/*.out" -type f)
          if [ ${#COVER_FILES[@]} -eq 0 ]; then
            echo "No coverage files found; skipping coverage gate."
            echo "skipped=true" >> "$GITHUB_OUTPUT"
          else
            echo "Merging ${#COVER_FILES[@]} coverage profiles"
            ./.tools/gocovmerge "${COVER_FILES[@]}" > .artifacts/merged-coverage.out
            echo "skipped=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Calculate current coverage percentage
        if: success() && steps.merge-coverage.outputs.skipped == 'false'
        id: coverage
        run: |
          PCT=$(go tool cover -func=.artifacts/merged-coverage.out \
            | grep "^total:" | awk '{print $3}' | tr -d '%')
          echo "percentage=${PCT}" >> "$GITHUB_OUTPUT"
          echo "${PCT}" > .artifacts/current-coverage.txt
          echo "Current coverage: ${PCT}%"

      - name: Restore baseline coverage from main
        if: success() && steps.merge-coverage.outputs.skipped == 'false'
        id: restore-baseline
        uses: actions/cache/restore@1bd1e32a3bdc45362d1e726936510720a7c30a57
        with:
          path: .artifacts/baseline-coverage.txt
          key: coverage-baseline
          restore-keys: |
            coverage-baseline

      - name: Gate on coverage regression
        if: success() && steps.download-artifacts.outputs.pr_number && steps.merge-coverage.outputs.skipped == 'false'
        id: coverage-gate
        run: |
          CURRENT="${{ steps.coverage.outputs.percentage }}"
          MINIMUM=95.0
          BASELINE_MSG="(no baseline yet)"
          failure_reasons=()

          if [ -z "$CURRENT" ]; then
            failure_reasons+=("coverage percentage is empty; go tool cover may have failed")
          else
            # Gate 1: absolute minimum (matches codecov.yml target: 95%)
            if (( $(echo "$CURRENT < $MINIMUM" | bc -l) )); then
              failure_reasons+=("coverage ${CURRENT}% is below required minimum ${MINIMUM}%")
            fi

            # Gate 2: no regression vs main baseline
            if [ -f .artifacts/baseline-coverage.txt ]; then
              BASELINE=$(cat .artifacts/baseline-coverage.txt)
              if [ -z "$BASELINE" ]; then
                failure_reasons+=("baseline coverage file is empty; cannot perform regression check")
              else
                BASELINE_MSG="(baseline ${BASELINE}%)"
                if (( $(echo "$CURRENT < $BASELINE" | bc -l) )); then
                  failure_reasons+=("coverage dropped from ${BASELINE}% to ${CURRENT}%")
                fi
              fi
            fi
          fi

          if [ ${#failure_reasons[@]} -gt 0 ]; then
            msg=$(IFS='; '; echo "${failure_reasons[*]}")
            echo "conclusion=failure" >> "$GITHUB_OUTPUT"
            echo "summary=${msg}" >> "$GITHUB_OUTPUT"
            echo "::error::${msg}"
          else
            echo "conclusion=success" >> "$GITHUB_OUTPUT"
            echo "summary=Coverage ${CURRENT}% ${BASELINE_MSG}" >> "$GITHUB_OUTPUT"
          fi

      - name: Append coverage section to combined summary
        if: success() && steps.download-artifacts.outputs.pr_number && steps.merge-coverage.outputs.skipped == 'false'
        run: |
          {
            echo ""
            echo "## Code Coverage"
            echo ""
            echo "${{ steps.coverage-gate.outputs.summary }}"
          } >> ./.artifacts/combined_summary.md

      - name: Post PR comment with combined summary
        if: |
          (steps.compare-metrics.outputs.TOTAL_CHANGES != '0' ||
           steps.compare-metrics.outputs.HAS_ERROR == 'true' ||
           steps.coverage-gate.outputs.conclusion == 'failure') &&
          steps.download-artifacts.outputs.pr_number
        uses: thollander/actions-comment-pull-request@24bffb9b452ba05a4f3f77933840a6a841d1b32b # v3
        with:
          file-path: ./.artifacts/combined_summary.md
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          comment-tag: "## CI Summary Report"
          pr-number: ${{ steps.download-artifacts.outputs.pr_number }}

      - name: Create check run for metrics comparison
        if: success() && steps.download-artifacts.outputs.pr_number
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const headSha = context.payload.workflow_run.head_sha;
            const totalChanges = parseInt('${{ steps.compare-metrics.outputs.TOTAL_CHANGES }}' || '0');
            const hasError = '${{ steps.compare-metrics.outputs.HAS_ERROR }}' === 'true';
            const artifactLink = 'https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}';

            let conclusion, summary, text;

            if (hasError) {
              conclusion = 'failure';
              summary = '❌ Metrics comparison failed';
              text = 'ERROR: No summary files were generated. Expected at least 8 diff files from CI.\n\nThis indicates a failure in the E2E test execution or metrics collection process.\n\n➡️ [View full metrics file](' + artifactLink + ')';
            } else if (totalChanges === 0) {
              conclusion = 'success';
              summary = '✅ No significant metric changes detected';
              text = `Total changes across all snapshots: ${totalChanges}\n\n➡️ [View full metrics file](${artifactLink})`;
            } else {
              conclusion = 'failure';
              summary = `❌ ${totalChanges} metric changes detected`;
              text = `Total changes across all snapshots: ${totalChanges}\n\n➡️ [View full metrics file](${artifactLink})`;
            }

            await github.rest.checks.create({
              owner,
              repo,
              name: 'Metrics Comparison',
              head_sha: headSha,
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: 'Metrics Comparison Result',
                summary: summary,
                text: text
              }
            });
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create check run for coverage gate
        if: success() && steps.download-artifacts.outputs.pr_number && steps.merge-coverage.outputs.skipped == 'false'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const headSha = context.payload.workflow_run.head_sha;
            const conclusion = '${{ steps.coverage-gate.outputs.conclusion }}';
            const summary = '${{ steps.coverage-gate.outputs.summary }}';
            const artifactLink = 'https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}';

            await github.rest.checks.create({
              owner,
              repo,
              name: 'Coverage Gate',
              head_sha: headSha,
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: 'Coverage Gate',
                summary: conclusion === 'success' ? `✅ ${summary}` : `❌ ${summary}`,
                text: `➡️ [View CI run](${artifactLink})`
              }
            });
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Save baseline coverage on main-branch runs so PRs can compare against it.
      # Uses the same actions/cache pattern as .github/actions/verify-metrics-snapshot/action.yaml.
      - name: Save coverage baseline on main branch
        if: |
          github.event.workflow_run.head_branch == 'main' &&
          steps.merge-coverage.outputs.skipped == 'false'
        run: cp .artifacts/current-coverage.txt .artifacts/baseline-coverage.txt

      - name: Cache coverage baseline
        if: |
          github.event.workflow_run.head_branch == 'main' &&
          steps.merge-coverage.outputs.skipped == 'false'
        uses: actions/cache/save@1bd1e32a3bdc45362d1e726936510720a7c30a57
        with:
          path: .artifacts/baseline-coverage.txt
          key: coverage-baseline_${{ github.run_id }}
